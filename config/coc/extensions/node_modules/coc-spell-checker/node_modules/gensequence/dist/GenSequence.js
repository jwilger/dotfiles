"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("./operators/operators");
function genSequence(i) {
    const createIterable = (typeof i === "function") ? i : () => i;
    function fnNext() {
        let iter;
        return () => {
            if (!iter) {
                iter = createIterable()[Symbol.iterator]();
            }
            return iter.next();
        };
    }
    const seq = {
        [Symbol.iterator]: () => createIterable()[Symbol.iterator](),
        next: fnNext(),
        //// Filters
        filter: (fnFilter) => genSequence(() => operators_1.filter(fnFilter, createIterable())),
        skip: (n) => {
            return genSequence(() => operators_1.skip(n, createIterable()));
        },
        take: (n) => {
            return genSequence(() => operators_1.take(n, createIterable()));
        },
        //// Extenders
        concat: (j) => {
            return genSequence(() => operators_1.concat(createIterable(), j));
        },
        concatMap: (fn) => {
            return genSequence(() => operators_1.concatMap(fn, createIterable()));
        },
        //// Mappers
        combine: (fn, j) => {
            return genSequence(() => operators_1.combine(fn, createIterable(), j));
        },
        map: (fn) => genSequence(() => operators_1.map(fn, createIterable())),
        scan: (fnReduce, initValue) => {
            return genSequence(() => operators_1.scan(createIterable(), fnReduce, initValue));
        },
        // Reducers
        all: (fnFilter) => {
            return operators_1.all(fnFilter, createIterable());
        },
        any: (fnFilter) => {
            return operators_1.any(fnFilter, createIterable());
        },
        count: () => {
            return operators_1.count(createIterable());
        },
        first: (fnFilter, defaultValue) => {
            return operators_1.first(fnFilter, defaultValue, createIterable());
        },
        forEach: (fn) => {
            return operators_1.forEach(fn, createIterable());
        },
        max: (fnSelector) => {
            return operators_1.max(fnSelector, createIterable());
        },
        min: (fnSelector) => {
            return operators_1.min(fnSelector, createIterable());
        },
        reduce: (fnReduce, initValue) => {
            return operators_1.reduce(fnReduce, initValue, createIterable());
        },
        reduceToSequence: (fnReduce, initialValue) => {
            return genSequence(operators_1.reduce(fnReduce, initialValue, createIterable()));
        },
        //// Cast
        toArray: () => [...createIterable()],
        toIterable: () => {
            return toIterableIterator(createIterable());
        },
    };
    return seq;
}
exports.genSequence = genSequence;
// Collection of entry points into GenSequence
exports.GenSequence = {
    genSequence,
    sequenceFromRegExpMatch,
    sequenceFromObject,
};
//// Cast
function* toIterableIterator(i) {
    yield* i;
}
exports.toIterableIterator = toIterableIterator;
/**
 * alias of toIterableIterator
 */
exports.toIterator = toIterableIterator;
function* objectIterator(t) {
    const keys = new Set(Object.keys(t));
    for (const k in t) {
        // istanbul ignore else
        if (keys.has(k)) {
            yield [k, t[k]];
        }
    }
}
exports.objectIterator = objectIterator;
function objectToSequence(t) {
    return sequenceFromObject(t);
}
exports.objectToSequence = objectToSequence;
function sequenceFromObject(t) {
    return genSequence(() => objectIterator(t));
}
exports.sequenceFromObject = sequenceFromObject;
function sequenceFromRegExpMatch(pattern, text) {
    function* doMatch() {
        const regex = new RegExp(pattern);
        let match;
        let lastIndex = undefined;
        while (match = regex.exec(text)) {
            // Make sure it stops if the index does not move forward.
            if (match.index === lastIndex) {
                break;
            }
            lastIndex = match.index;
            yield match;
        }
    }
    return genSequence(() => doMatch());
}
exports.sequenceFromRegExpMatch = sequenceFromRegExpMatch;
exports.default = genSequence;
//# sourceMappingURL=GenSequence.js.map